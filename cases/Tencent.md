# 腾讯面试题目

## 一面，电话面试

### 1. **(2)spring 怎么判断产生循环依赖** [Spring循环依赖的三种方式以及解决办法](https://www.cnblogs.com/liuqing576598117/p/11227007.html) [spring中的循环依赖解决方案](https://www.jianshu.com/p/b65c57f4d45d)
- 对于构造器循环依赖的情况，spring容器会为正在创建的bean创建标识符并缓存，那如果发现标识符已经存在时，就会抛出异常；
    - 可以采用@Lazy延时加载的办法来解决，原理是注入的是spring生成的代理类，只有第一次使用的时候才会加载。
- 对于Setter单例循环依赖的情况，spring会维护一个beanName对应的半成品Bean 和 beanName对应的beanFactory，通过递归不断创建半成品bean，回溯时候则依次设置属性的reference。 [高频面试题：Spring 如何解决循环依赖？](https://zhuanlan.zhihu.com/p/84267654)
- 对于Setter原型循环依赖情况，spring不会缓存半成品bean，因此无法解决，会抛出异常
### 2. **innodb索引结构有哪些**
- B+树
- Hash树
### 2. **innodb存储结构有哪些** [REF](https://zhuanlan.zhihu.com/p/35811482)
- 最外层是表空间，内部又分为 段、区、页、行
- 段 包含索引段、数据段、回滚段
- 区 大小为1M，包含64个连续的页
- 页 大小为16K，
- 行 一条记录最小为2字节，所以最多8000行左右。一般互联网的表，一条记录1K左右，所以大概能容纳16行。
### 3. **(2)非聚簇索引和聚簇索引**
- 聚簇索引的非叶子节点存储的是关键字和指向子节点的指针，叶子节点存储的是具体的数据
- 非聚簇索引的非叶子节点存储的同样是关键字和指向子节点的指针，叶子节点存储的是主键id
### 4. **b+  3层能存多少数据**
- 2000万左右
- 默认页大小为16K，叶子节点按1K计算能放16个。非叶子节点有2层，每一层存储的都是主键id和指向子节点的指针，主键id8个字节，指针6个字节，这样计算的话，就是两千万左右
### 5. **(2)区间查询怎么做的**
- innodb数据结构是B+树，它的叶子节点有指向下一个兄弟节点的指针，所以能通过指针进行范围查询。
### 6. **秒杀要注意哪些**
- 安全
    - 秒杀连接不要泄露了
- 稳定、性能
    - 单独部署在高性能服务器上（防止影响其他系统）
    - 负载均衡，用多个实例
    - 对用户请求限流，对全局请求限流
    - 动静分离，可使用cdn，redis等
    - 缓存热点数据
    - 使用队列异步处理下单
    - 把对库存的读写放到redis里面来做
- 数据一致
    - 乐观锁，比如版本号实现
### 6. **(2)mq怎么保证不丢消息**
- 平时工作中接触的比较多的是RocketMQ，我就讲讲Rocket吧
- 发送方丢失：
    - 发送方发送后会收到一个ACK，告知成功或失败，失败的时候可通过重试机制再次发送。如果仍然失败就需要自己添加补偿逻辑。
    - 不推荐使用事务消息，因为即使是事务消息也不保证成功。
- Broker丢失：持久化才能算消息投递成功，消息一开始会持久化到CommmitLog中，即使待机重启，也能恢复。同时它的同步刷盘、异步刷盘和同步复制、异步复制都可以保证消息存储在至少一个节点中
- 接收方丢失：接收方本地会维护一个持久化的 consumer offset，并且会实时上报给broker，即使失败了也会定期重试。即使Consumer挂了也没事儿，因为consume offset是持久化的。
### 7. **(2)分布式事务  最终一致性具体实现细节**
- 常见的方案有，2PC、TCC、本地消息表、事务消息+最终一致性、Sagas协同式和编排式。
- 最后要说的就是阿里的Seata了，功能强大，支持了XA、TCC、SAGA、AT 多种事务模式。
- 我们项目中使用的是 RocketMQ事务消息 + 最终一致性解决，要求不严格的业务也是用普通消息+最终一致性，毕竟事务消息性能差些。
### 8. **seata问题**
- AT 需要使用方只是本地ACID事务，原理是：业务数据和回滚日志在同一个本地事务中提交，失败则通过回滚日志进行回滚
- TCC 倒是不需要本地ACID事务支持，但是需要开发者对每一个事务都要提供prepare、commit、rollback逻辑，工作量有点大
- Saga 模式就比较复杂了，之前看微服务架构模式里面有讲这个东西，分了编排式和协同式，编排式更好。seata里面怎么实现的还没看过。
### 9. **分库分表会产生的问题分库**
- Join问题
- 排序分页问题
- 我们的项目中只做了分库和垂直分表，没有做水平分表。
- 在我们的这种场景下，分库数据是会通过canal同步到ES中的，统计不成问题
### 9. **canal是什么原理**
- canal其实就是一个mysql的slave，
- 就是slave 连接到master后嘛，就会开启一个IO线程，去读取master的binlog到自己relaylog中，然后会有sql线程把relaylog的内容重新执行一遍
- 然后这儿的执行其实是同步的，所以说slave可能会延迟（防止出现并发安全）。想要解决的话可以开启半同步机制，它会要求至少一个slave返回了ack才算写成功。（还有一个是并行复制，是库级别的重放relaylog。）
### 10. **不能join怎么解决**
- 可以用全局表（把这个要关联的表同步或复制到每一个要使用它的地方。）
- 然后ER分片（把有关联的数据放在一个分片中。）
- 再或者代码层解决。
### 11. **(2)怎么做sql优化的  索引失效有哪些情况**
- sql优化：
    - 这样吧，我用最近优化的一个接口来举例：
    - 首先是主键索引：需要单调递增的Long型主键，使用redis按照snowflake算法生成。一方面，单调递增避免页分裂；另一方面，要求主键分布式唯一。
    - 然后 覆盖索引：该接口会用到设备表的一些信息，为了避免join超过5张表，所以我是在业务逻辑层单独进行设备查询。那为了加快查询效率，就为设备表添加了覆盖索引。
    - 然后 最左匹配原则：where条件多，所以使用联合索引，提高查询效率。
    - 列区分度原则：将区分读最高的列放在联合索引的最左侧，所以把deviceId放在了最左侧，它在我们系统中是比商户/门店GUID 更容易区分的列。
    - in关键字的索引匹配：将第一个 in 作为联合索引的最后一个列，将另一个 in 的列拆分为多个查询，并使用 union all 汇总结果行。这样子每一个查询都能走索引。
    - 因条件缺省造成的索引匹配失效：在代码层做判断，调用不同的查询语句，避免因缺省值造成联合索引失效。
    - 排序规则：这个sql有分页需求，但排序规则很复杂，无法在数据库实时完成。然后，考虑到这张表的读请求远大于写请求，因此在写请求时，更新排序字段的值，以便读请求时能在DB层面做分页，避免读取大量数据到内存中分页。
    - 最后，肯定是要用explain分析一下：对于该接口的各种参数组合进行explain分析，确保都能走索引。
- 索引失效
    - 前模糊
    - 条件中有 or
    - 条件中有 计算、函数、类型转换
    - 联合索引不满足最左匹配原则
### 12. **redis  事务原子性**
- 都说是假原子性，因为后面失败后前面不会回滚。但是呢作者也说了，redis只会因为错误的语法而失败，是编程造成的，应该在开发阶段就被解决掉，不应该出现在生产环境。所以redis也不会支持回滚这个功能。
### 13. **redis rdb细节，怎么保证数据不出错**
- 有 SAVE 和 BGSAVE 两个指令可以让redis生成RDB文件
- SAVE的话是阻塞执行的，客户端发送的数据都会被拒绝，所以没有并发问题，数据不会出错
- BGSAVE的话是fork了子线程来执行的（fork的时候是阻塞主线程的），？？？？问宏洋，出错是丢失的意思？
### 13. **redis aof细节**
- append-of file 文件追加的方式，相比较rdb实时性更好，可以设置为每秒同步一次
### 14. **Redlock什么情况下不可靠**[怎样做可靠的分布式锁，Redlock 真的可行么？](https://blog.csdn.net/chen_kkw/article/details/81433470)
- 时间回溯情况下不可靠
- 比如5个节点，线程1加锁，123节点加锁成功，45节点因为网络问题未到达，此时整体加锁成功。
- 但是节点3发生了时间回溯，线程2执行加锁，345节点加锁成功，此时有2个线程都获取了锁，不可靠了。
- 再比如GC停顿时间过长，超过了锁过期时间，也会不可靠。
### 15. **为什么多节点使用Redlock**
- 多节点情况下，不用redlock就无法获取了。加锁可能发生在任何一个节点上，比如5个节点，甚至能拿到5把锁。
### 16. **分布式锁**
- 严格一致性就用zookeeper吧，不严格的话，主从可以用redisson，集群可以用redlock
- redisson
    - 加锁：lock键不存在则设置线程信息并获取到锁；若是当前线程加锁的就重入+1，然后重新设置过期时间并，返回加锁成功；否则的话就返回锁过期时间，告诉客户端等待。
    - 解锁：lock键不存在，锁已经可用；线程不一致，返回错误；减1后大于0就重设过期时间，否则删除key，此时别的线程可获取锁
### 17. **zookeeper怎么实现的  怎么保证节点顺序的**
- 首先创建一个持久化的父节点，当一个客户端想要获取锁时，需要在父节点下创建一个临时顺序节点。之后客户端拉取该父节点下的所有临时节点，判断跟自己创建的节点是否为第一位，如果是，获取到锁，如果不是，向前一个节点注册Watcher。
- 保证节点顺序：父节点根据子节点的创建时间，然后维护了一个自增序列
- （补充）无恶意节点时可采用paxos和raft，有恶意节点的话bitcorn的 proof of work方法，作恶要付出巨大的经济代价
### 18. **(2)concurrentHash什么时候用到syc**
- 链表的头节点不存在时用CAS设置头节点
- 如果存在的话则对头节点/或红黑树根节点加sync同步锁
### 19. **mybatis源码**
- 接触不是很多
### 20. **怎么把数据转成对象的**
- 可以通过resultMap标签或者列别名，然后用反射生成对象。
- 源码的话记不清了：大概是通过mapping取出映射关系，然后通过typeHandler解析每个值，最后存储到resultHandler中返回
### 21. **直接用jdbc怎么防止sql注入**
- 使用 PreparedStatement，本质上是对用户输入的字符串进行了转义，前后增加单引号或双引号
### 22. **联合索引最左原则查询非聚簇索引过程** [mysql 联合索引 数据结构是怎样的](https://segmentfault.com/q/1010000017579884/)
- 联合索引可以理解为非叶子节点上有多个关键字+一个指向字节点的指针，比如(a,b,c)的联合索引，如果只是查ab,那就找到第一个匹配ab的叶子节点，然后通过指向兄弟节点的指针继续范围查询。最后得到主键列表后回聚簇索引取数据。
### 23. **(2)tcp  time wait问题** [TCP TIME_WAIT状态解析及问题解决](https://blog.csdn.net/zhaobryant/article/details/80557158)
- 客户端发送最后一次ACK后就会进入time-wait状态，持续时间为2MSL（linux中1个MSL是30秒且不可配置）
- 作用：最后一次ACK，服务端可能会没收到。这个时候服务端会再次发送FIN，还处在time-wait状态的客户端就有机会再次ACK。
- 问题：
    - 新连接可能会被延迟或重复的FIN影响
    - 服务段可能会被客户端回复的RST影响
    - （补充）time wait bucket table overflow 问题：time-wait状态的连接超过了系统定义的阈值（默认1870000，改为5000较好）
        - 可以加 tcp_tw_reuse 进行优化
### 24. **(2)cms和g1的区别   g1在什么场景下使用**
- 区别
    - 两者都是并发的垃圾收集器，用户线程和gc线程可以同时运行
    - cms采用的标记清除算法，会有大量空间碎片产生。而gc整体采用标记整理，局部是复制算法（将存活的对象从一个分区拷贝到另一个可用分区），所以不会产生大量空间碎片
    - cms的stw时间不如g1可控，gc1能做到精确预测停顿时间
- 使用场景
    - 大内存、低GC停顿时间
    - 应用运行过程会产生大量内存碎片时可以用
    - 需要更加可控的GC停顿时间，防止雪崩效应，可以用
    - gc停顿时间可控的同时也不会牺牲吞吐量时，可以用

        （补充）
        G1的设计初衷是为用户提供大内存、低GC停顿时间的应用解决方案。这意味着堆内存6G或更大，停顿时间稳定且少于0.5秒。

        如果应用正在使用CMS或ParallelOld且面临以下问题，推荐将应用迁移至G1

        FullGC发生频繁或总时间过长
        对象分配率或对象升级至老年代的比例波动较大
        较长的垃圾收集或内存整理停顿（大于0.5至1秒）

### 25. **cms浮动垃圾怎么产生的**
- 第二次并发标记的时候，用户线程和gc线程同时在运行，用户线程可能会将已标记为可达对象修改为不可达，于是该对象变成浮动垃圾，需要下次才能清理掉
- （补充）第二次并发标记还可能产生对象消失问题，原理记不清了
### 26. **操作系统怎么支持nio**
- 非阻塞IO：反复调用recvfrom以等待数据报准备好，然后阻塞进行读取
- IO多路复用：select函数阻塞获取可读事件，然后调用recvfrom读取数据报
- 非阻塞指的是数据准备阶段非阻塞，数据读取阶段都是阻塞的。select阻塞只是select函数阻塞，socket是没阻塞的
- 操作系统：
    - select：需要将文件描述符从用户态拷贝到内核态，并进行遍历，性能差。同时文件描述符有最大限制1024
    - poll：跟select差不多，但是文件描述符没有最大限制（使用链表存储的）
    - epoll：内核和用户空间映射为同一块儿内存，无需拷贝。通过注册fd，内核callback机制通知，无需遍历。
    - 所以，最好是采用epoll方式。
### 27. **(2)netty**
- netty的话使用了reactor主从线程模型实现，bossGroup和workderGroup。基于epoll机制，IO多路复用，同步非阻塞模型
- 平时使用的话，创建Boss和workerGroup，定义handerChain，包括 协议、编解码、序列化、拆包粘包、自定义handler 等
### 28. **es倒排索引**
- 先对文本内容进行分词，然后对每个分词进行分类，记录关联的doc_id。那么这么一张关联表就称为倒排索引。
- 我们项目中主要用于精确搜索，所以设置的是 not_analysize，查询的时候也全用的 term 查询。
- 补充：
    - es写入数据流程：请求发送到协调节点，然后对doc进行路由并转发到对应节点的主分片，再由主分片同步给副本分片。都搞定之后，协调节点就返回响应给客户端
    - es读取数据流程：请求发送到协调节点，然后对doc进行路由并根据轮循策略转发到主副分片以读取数据，读取到后，再由协调节点返回数据给客户端
    - es搜索数据流程：请求发送到协调节点，然后对doce进行分词，并路由到相应的分片进行查询，再由协调节点汇总处理数据，然后根据doc_id去各分片取具体的数据
### 29. **怎么保证服务高可用**
- 系统中的每个组建都尽量保持高可用，比如：nginx 2个实例+keepalive 部署，网关/服务多个副本，redis主从或集群，mysql主从或集群 等等
- 链路上的话：限流、超时、熔断、降级 等手段保障服务稳定性。
- 有钱的话，两地三中心、三地五中心都可以上。
### 30. **一致性哈希原理** [一致性HASH算法详解](https://www.jianshu.com/p/e8fb89bb3a61)
- 一致性hash是利用hash环解决普通的余数hash伸缩性很差的问题
- 原理的话：计算节点ip的hash值，于是多个节点在hash环上就是一个环状结构。这样子当请求到来时，计算请求的hash值，这个值落到hash环上，然后顺时针寻找最近的ip作为路由ip。
### 31. **节点数少不均衡怎么办**
- 这种情况称为 一致性hash倾斜，可以使用虚拟节点解决
### 32. **代码中怎么实现获取虚拟节点的数据范围**
- 因为是环状嘛，所以可以遍历实现。假设所有的节点用数组存储，且是有序的，那么从头开始便利遍历，知道找到比请求的hash值大的节点。
- 如果求真实节点所有的范围的话，就要根据真实节点所映射的虚拟节点列表，然后执行遍历查找，最后结果汇总。
- （补充）因为节点下线要剔除虚拟节点，所以需要“真实节点到虚拟节点列表的映射，即一个map”
- （补充）因为要根据虚拟节点定位真实节点，所以需要“虚拟节点到真实节点的映射，即一个map”
### 33. **hystrix 线程隔离  信号量是怎么实现的   线程池隔离怎么实现的**
- 包含 信号量隔离 和 线程池隔离，可以指定全局默认值，也可以指定具体的服务
- 信号量实现：利用semphore实现的话，只能限定最大的并发数，无法对具体的接口隔离。底层是通过 AtomicInteger 实现，没有用JDK的Semphore。
- 线程池实现：粒度就小很多了，可以制定接口级别的线程池配置。底层是通过 ConcurrentHashMap 实现，key是threadPoolKey，value是HystrixThreadPool。
### 34. **ribbon请求策略有哪些**
- 随机 random
- 轮询 round robin
- 重试 retry
- 区域 zone
- 加权 weighted
### 35. **怎么确定服务不可用  默认超时时间**
- 这里有三个组件的超时时间
- 一个是feign，默认连接超时10秒，默认读取超时60秒
- 一个是hystrix，默认熔断时间是1秒
- 还有一个是ribbon，默认连接超时10秒，默认读取超时60秒
- 所以如果不加以自定配置的话，1秒后就会熔断。我们项目中一般设置ribbon的2秒连接，5秒读取，没有开启重试，所以hystrix也配置的5秒熔断。
### 36. **(2)怎么分析内存溢出  什么命令导出dump   dump里面包含什么**
- dump出堆栈信息
- jmap -dump:format=b,file=dump.hprof <pid>，   或者 一些自动命令，比如 dumpOnOutOfMemory
- 包含 线程情况、对象及引用链、类加载情况 等
- 工具：jhat，eclipse的mat，ibm的memory anaylizer
### 37. **TransactionManager的实现原理**
- todo
### 38. **了解其他mq吗，能讲原理那种**
- todo
### 39. **ConcurrentHashMap的实现原理**
- 1.8之前...
- 1.8之后...
### 40. **项目中的架构及技术点**
- 略