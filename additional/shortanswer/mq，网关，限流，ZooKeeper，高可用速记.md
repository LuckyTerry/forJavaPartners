# mq 网关 限流 ZooKeeper 高可用速记：
1. 消息队列的作用和副作用
- 作用
    - 异步处理：提高系统性能，如 “订单服务调用打印服务来打印票据”
    - 削峰填谷：如 “打印服务接收其他服务的大量打印请求”、“消息服务接收其他服务的消息推送”
    - 降低系统耦合性：如 “组织服务的创建门店，感兴趣的服务可自行订阅到门店创建topic”
- 副作用
    - 系统可用性降低，因为 MQ可能会挂掉
    - 系统复杂性提高，比如 MQ高可用配置、重复消费、消息顺序、分布式事务、消息堆积 等问题
    - 一致性问题，比如 消费异常导致数据不一致了
2. 队列模型 和 主题模型
- 队列模型：只有一个队列负责存储，就像 BlockingQueue 一样
- 主题模型：又称发布订阅模型，发布者将消息发送到指定主题中，订阅者需要 提前订阅主题 才能接受特定主题的消息
3. 每个消费组在每个队列上维护一个消费位置 ，为什么呢？
- 消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要呀)，它仅仅是为每个消费者组维护一个 消费位移(offset) 
4. 为什么一个主题中需要维护多个队列 ？
- 提高并发能力，消费者组可以有多个消费者，至少要为每个消费者绑定一个队列才能达到较好的性能
5. 4组件
- NameServer：Broker管理 和 路由信息管理 
- Broker：主要负责消息的存储、投递和查询
- Producer：消息发布的角色
- Consumer：消息消费的角色
- 以上所有组件都需要高可用部署才行：
    - NameServer 多副本，去中心化部署
    - Broker 分片 + 主从，从节点只支持读，不支持写入
    - Producer、Consumer 多副本部署
5. Consumer的读取数据方式
- Push 略
- Pull RocketMQ默认使用Pull的方式，具体实现是长轮循，Broker收到请求后，如果队列没有数据便会阻塞请求，一直等到产生数据或超时时间到
5. Consumer的两种启动模式
- 广播模式：一条消息发送后，消费组里的每一个消费者都会收到消息
- 集群模式：一条消息发送后，消费组里只有一个消费者会收到消息
6. 如何解决 顺序消费、重复消费
- 顺序消费
    - 分为 严格顺序 和 普通顺序
    - 严格顺序下，集群里只要有一台机器不可用，则整个集群不可用
    - 普通顺序下，不会有这个问题，但是顺序不一定有序。可以通过 Hash取模 的方式来保证同类型消息在同一个队列，以保证顺序
- 重复消费
    - MQ保证消息一定消费，但是不保证重复消费，所以需要业务端实现幂等，可以通过数据库唯一键或者Redis来实现
7. rocketMq的分布式事务实现
- 事务消息 + 事务反查机制，步骤是， 发送消息->事务处理->提交或回滚->事务反查->提交或回滚
8. 消息堆积问题
- RocketMQ支持千万级的消息堆积，这也是我们系统采用它的最主要原因
- 当发生了消息堆积后，可以快速增加消费者数量和队列数量，以加快消费速度
9. 回溯消费
- Broker 在向Consumer 投递成功消息后，消息仍然是保留的，可以按照时间维度来回退消费进度
10. RocketMQ 的刷盘机制
- 分为同步刷盘和异步刷盘
11. 同步刷盘和异步刷盘 同步复制和异步复制
- 同步刷盘和异步刷盘
    - 同步刷盘：数据存储到磁盘上是同步的。可靠性强，性能差，适用于特定环境如金融行业
    - 异步刷盘：数据存储到磁盘上是同步的。可靠性稍弱，性能好，使用与对于消息保证要求不太高的场景
- 同步复制和异步复制
    - 主从模式下
    - 同步复制： 消息同步双写到主从结点上才返回写入成功 
    - 异步复制： 消息写入主节点之后就直接返回写入成功。不影响可靠性，只影响可用性，可使用Dledger来自动选举 leader broker
12. 存储机制
- 略
13. 什么是API网关
- 系统与外界联通的入口，我们可以在网关进行处理一些非业务逻辑的逻辑，比如权限验证，监控，缓存，请求路由等等。
14. 为什么需要API网关
- 可以完成 动态路由、身份认真、统一鉴权、限流 等
15. 业务隔离
- 分为 信号量隔离、线程池隔离 和 集群隔离
16. 信号量隔离
- 限制了总的并发数
17.  线程池隔离
- 不同业务之间通过不同的线程池进行隔离，业务之间互不影响
18. 集群隔离
- 重要的业务单独部署为一个集群
19. 限流的算法有哪些？
- 令牌桶，限制的是平均流入速率，允许一定程度突发流量；
- 漏桶，限制的是常量流出速率，从而平滑突发流入速率；
- Sentinel和Hystrix都是基于滑动窗口
20. 什么是高可用？可用性的判断标准是啥？
- 高可用描述的是一个系统在大部分时间都是可用的，即使在发生硬件故障或者系统升级的时候，服务仍然可用
- 一般情况下，我们使用多少个 9 来评判一个系统的可用性。当前我们系统的SLA是99%。
21. 些情况可能会导致系统不可用？
- 我讲一讲我们遇到过的：
- 并发请求过多、发生内存泄漏、某个组件不可用、ECS不可用、自然灾害、人为攻击 等
22. 有些提高系统可用性的方法？
- 代码质量
- 集群部署
- 限流、降级、熔断
- 异步调用、使用缓存
23. ZAB 协议&Paxos算法
- 
24. ZooKeeper简介 设计目标
- 分布式协调服务
- 将那些容易出错的分布式组件封装起来，提供一系列简单的接口供用户使用
25. ZooKeeper 特点
- 顺序一致性
- 原子性
- 单一系统映像
- 可靠性
26. 数据模型  构建集群 顺序访问
- 允许通过共享的层次结构命名空间进行相互协调，与标准文件系统类似；名称空间由 ZooKeeper 中的数据寄存器组成，称为znode，这些类似于文件和目录。
- 以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么zookeeper本身仍然是可用的
- 
27. Zookeeper的分布式锁原理
- 临时有序节点
- 节点事件监控
- 若节点位于第一个位置表示获取到了锁，否则对前面的节点进行watch，前面的节点删除后会通知当前节点。
