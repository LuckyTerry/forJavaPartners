# 并发和jvm速记

1. 线程，进程，协程
- 进程：进程是程序的一次执行过程，是系统运行程序的基本单位
- 线程：线程是一个比进程更小的执行单位。一个进程可以产生多个线程，多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈
- 协程：可以理解为用户空间下的线程，更加轻量级

2. 介绍下 Java 内存区域（运行时数据区）线程私有3为什么私有，线程共享3
    - Java相关的内存有 直接内存 和 运行时数据区
    - 其中运行时数据区分为 线程共享的堆、方法区 和 线程私有的程序计数器、虚拟机栈、本地方法栈
- 程序计数器 作用
    - 程序计数器是字节码的行号指示器，它有俩个作用
    - 一个是字节码解释器通过改变程序计数器的值来依次读取指令
    - 另一个是用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了
- 虚拟机栈
    - 数据结构是栈，元素是一个个栈帧。函数调用入栈，函数返回或抛异常出栈
- 本地方法栈
    - 同虚拟机栈，不过执行的是native方法
- 栈帧中都拥有信息
    - 局部变量表、操作数栈、动态链接、方法出口信息
-  Java 虚拟机栈和本地方法栈会出现哪两种异常
    - StackOverFlowError 和 OutOfMemoryError
- 怎么模拟两种异常
    - 递归调用函数模拟 StackOverFlowError
    - 将-Xmx和-Xms设小一点，然后alloc大数组
- 栈调用深度和溢出内存大小固定的么
    - 不固定，动态计算的
- 堆
    - 存放对象实例，几乎所有的对象实例以及数组都在这里分配内存
- GC堆细分
    - 分为 新生代 和 老年代，默认比例1:2
    - 新生代可细分为 Eden区、Survivor From 和 Survivor To，默认比例 8:1:1
    - 划分的目的是更好地回收内存，或者更快地分配内存
- Java8内存模型—永久代(PermGen)和元空间(Metaspace)
    - 永久代是HotSpot对于JVM规范的方法区的实现，在1.6之后的版本被移除了
    - 取而代之的就是元空间，位于直接内存中
- 运行时常量池属于哪个区域，存了什么东西
    - 1.6及之前实在方法区，1.6之后则是在Java堆里面
    - 存放了 类元信息、字面量、符号引用 等
- 直接内存
    - 直接内存不是运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。比如 Java NIO 和 Netty 的零拷贝技术，就是用到了直接内存
3. Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）
    - 类加载：根据全限定类名去常量池查找符号引用，判断是否进行了类加载、解析、初始化，如果没有，就进行类加载
    - 分配内存：如果内存没有碎片，就用 拉链冲突法 分配内存；否则就用 空闲列表法 分配
    - 初始化零值：保证了对象的实例字段在 Java 代码中可以不赋初始值就能直接使用
    - 设置对象头：类的元数据信息、对象的哈希码、对象的 GC 分代年龄、偏向锁等
    - 执行 init 方法：把对象按照程序员的意愿进行初始化
- HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程
    - 同上题
- 内存分配的两种方式 指针碰撞 空闲列表  什么情况用哪个
    - 内存没有碎片用指针碰撞，有碎片则用空闲列表
- 内存分配并发问题两种解决方式
    - TLAB：为每个线程预先在Eden区分配一块儿内存
    - CAS+失败重试：就是采用 CAS 配上失败重试的方式保证更新操作的原子性
- 对象在内存中的布局可以分为3块区域
    - 对象头：一部分是对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等），另一部分是类型指针，指向类元数据的指针
    - 实例数据：对象真正存储的有效信息
    - 对齐填充：仅仅起占位作用，因为自动内存管理系统要求对象起始地址必须是 8 字节的整数倍
4. 对象的访问定位的两种方式（句柄和直接指针两种方式）优缺点
- 指针：reference直接指向Java堆中的对象实例数据，实例数据中有指向方法区中对象类型数据的指针
- 句柄池：reference指向Java堆中的句柄池，句柄池持有Java堆的对象实例数据和方法区的对象类型数据
5. String类和常量池
- String 对象的两种创建方式
    - 字面量
    - new String
- String s1 = new String("abc");这句话创建了几个对象？
    - 可能一个，可能两个。如果常池中已存在“abc”，则只会在堆空间创建一个“abc”。否则首先在池中创建，然后在堆中创建。
- String 类型的常量池比较特殊。它的主要使用方法有哪两种？
    - 字面量
    - String.intern()
- String 字符串拼接
    - String 不可变，尽量使用StringBuilder或StringBuffer拼接
6. 8种基本类型的包装类和常量池
    - Boolean、Character、Byte、Short、Integer、Long、Float、Double
- 哪些实现了常量池技术，哪些没有
    - Boolean、Character、Byte、Short、Integer、Long 实现了常量池技术
    - 其中 Boolean有true和false，Character范围0-127，剩余范围-128到127
7. 多线程
- 为什么要使用多线程
    - 单核时代：提高cpu和io的综合利用率，因为io速度比cpu慢很多
    - 多核时代：多核并行执行任务，提高 CPU 利用率
    - 再说线程间的切换和调度的成本远远小于进程，而且现在动不动就要求百万级甚至千万级的并发量，多线程并发编程才能解决问题
- 线程的生命周期和状态6
    - 线程创建后是New状态
    - Thread.start之后是Ready状态
    - 获得CPU时间分片后是Running状态，java将Ready和Running统一归纳为Runable状态
    - 在Runnable状态时，调用Object.wait，Object.Join，LockSupport.park方法时会进入waiting状态；遇到Object.notify/notifyAll，LockSupport.unpark方法时又会回到Runnable状态
    - 与waiting状态对应的是time_waiting状态，在在Runable状态时，调用Thread.sleep，Object.wait带时间参数，LockSupport.parkNanos，LockSupport.parkUntils就会进入到Wait_timing状态；再遇到Object.notify/notifyAll，LockSupport.unpark或超时时间到，就会回到Runnable状态
    - 遇到同步方法、同步代码块就进入Blocked状态，获取到锁后回到Runnable状态
- 什么是上下文切换
    - 任务从保存到再加载的过程
- 什么是线程死锁，如何避免
    - 线程1持有A资源，线程2持有B资源，但是他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态
    - 造成死锁的4个必要条件
        - 互斥条件
        - 请求并保持条件
        - 不可剥夺条件
        - 循环等待条件
    - 根据4个必要条件破坏死锁
        - 一次性申请所有的资源
        - 申请其他资源时，如果申请不到，主动释放自己占有的资源
        - 按一致的顺序申请资源
- sleep方法和wait方法区别
    - 两者都可以暂停线程的执行
    - sleep未释放锁，而wait释放了锁
    - wait通常用于线程等待/通知，而sleep仅用于暂停执行
    - wait方法需要notify唤醒，而sleep和wait(带时间参数)超时可唤醒
- 调用start会执行run 为什么不直接调用run
    - 直接调用run会在调用函数的线程执行，而start方法则会启动一个线程去执行
8. synchronized关键字
- 对synchronized的了解
    - 解决的是多个线程之间访问资源的同步性，可以保证它修饰的方法和代码块在任意时刻只能有一个线程执行
- 3种使用方式
    - 静态函数：锁的是当前类
    - 实例函数：锁的是当前对象
    - 代码块儿：根据synchronized后面的参数来决定锁的是什么
- 手写单例模式，双重检验锁方式实现单例的原理 为什么要使用volatile 
    - 手写 略
    - 一个是保证内存可见性，另一个是禁止指令重排。因为对象的初始化和赋值指令可能会被JVM 重排，造成获得了实例，但是实例却未初始化
- 不使用volatile怎么导致对象逸出
    - 如上提所述
- javap命令用处
    - 反汇编，另外jad反编译
- synchronized关键字的底层原理
    - 代码块：moniterenter、moniterexit
    - 函数上：ACC_SYNCHRONIZED 标志
- monitor对象存在哪里
    - 对象头里边儿
- monitorenter、monitorexit、ACC_SYNCHRONIZED
    - 略
- 1.6之后对synchronized底层做了哪些优化
    - 主要是对锁进行了优化，详见下方
- 锁主要存在的4种状态
    - 无锁、偏向锁、轻量级锁、重量级锁
- 偏向锁
    - 偏向锁在无竞争的情况下会把整个同步都消除掉（偏的意思是，偏向于第一个获得它的线程）
- 轻量级锁
    - 轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量；但是在有竞争的情况下，由于多了一次CAS操作，所以性能比重量级锁更差
- 自旋锁和自适应自旋
    - 一般线程持有锁的时间都不长，所以为了这点儿时间就去挂起/恢复线程是得不偿失的。为了让线程等待，只需要执行一个忙循环，这个技术就叫做自旋。
- 锁消除
    - 虚拟机编译时，如果检测到共享数据不可能存在竞争，那么就执行锁消除
- 锁粗化
    - 如果对同一个对象反复加/解锁，还不如将锁的作用范围扩大
- synchronized 和ReentrantLock 的区别  ReentrantLock3点增强
    - 两者均可重入
    - synchronized基于JVM实现，和ReentrantLock基于AQS实现
    - 在过去ReentrantLock性能优于synchronized，但是现在synchronized已进行优化，两者性能已相当
    - ReentrantLock有3点增强
        - 支持中断
        - 支持公平锁
        - 支持多个条件的等待/通知
- 公平锁和非公平锁
    - 公平锁就是，先等待的线程先获得锁
    - 非公平锁就是，线程每次加锁都要先尝试获取一次，获取不到才等待
9. volatile 关键字
- 作用
    - 可见行（主内存、工作内存/高速缓存）
    - 禁止指令重排
- synchronized 和 volatile区别
    - volatile保证可见行，而synchronized还能保证原子性
    - 多线程访问volatile不会发生阻塞，而synchronized可能会发生阻塞
    - volatile主要用于解决变量在多个线程之间的可见性，而 synchronized解决的是多个线程之间访问资源的同步性
10. ThreadLocal 
- 简介用途
    - 让每一个线程都有自己的专属本地变量
- 内存泄漏问题
    - WeakRefence导致的内存泄漏，需要使用try/finally方式进行调用和remove
    - 虽然我们总说是WeakRefence导致的内存泄漏，但其实并不是。不管采用强引用还是弱引用，在各自场景下都存在内存泄漏的问题，只不过采用弱引用问题小一些。本质上，是由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key的value就会导致内存泄漏
- 关于内存泄漏我自己的理解
    - 第一，为什么要设置为WeakReference？
        - 假设使用强引用：一个傻傻的码农在方法中 new 了个本地变量 threadLocal 并 setValue，然后方法执行完了。之后由于外界拿不到threadLocal的引用了，无法访问到threadLocalMap中的entry，造成内存泄漏；但是聪明的码农都是用static threadLocal定义的，所以之所以定义为WeakRef，就是为了防止出现最坏情况。
        - 而当使用WeakRef时：方法结束后threadLocal强引用消失，此时仅有threadLocalMap中还存在对threadLocal的弱引用，遇上了YGC便回收了threadLocal。虽然也造成了内存泄漏，但是 null key 给了源码“判断可以清除”的依据。
    - 第二，平时都是定义的 static ThreadLocal，会触发threadLocalMap#Entry的theadLocal弱引用回收导致取不到value吗？
        - 不会的！因为外部还有 static 强引用，WeakRef只会在“对象没有其他强引用”的情况下才会被回收！
11. 线程池
- 为什么要用线程池
    - 降低资源消耗：因为可以 复用已创建的线程降低线程创建和销毁带来的消耗
    - 提高响应速度：因为 有活跃线程能立即执行
    - 提高线程的可管理性：因为可以 统一的分配，调优和监控
- 实现Runnable 和Callable接口区别
    - Runnable没有返回值
    - Callable有返回值
- execute() submit() 区别
    - execute 执行Runnable方法
    - submit 执行Callable方法，返回一个Future。也可以新建个FutureTask对象，交给submit执行。
- Executors 创建线程池的缺点
    - 队列无界，如Fixed和Single
    - 线程无界，如Cahced
    - 大量的队列元素和大量的线程都有可能造成OOM
- ThreadPoolExecutor 构造参数
    - coreSize
    - maxSize
    - keep alive 和 unit
    - queue 和 queueSize
    - ThreadFactory
    - Reject Handler
    - 执行过程是：请求到来；创建线程直到核心线程数，放入等待队列；如果等待队列已满，则创建线程直到最大线程数；如果最大线程数已满，则执行拒绝策略。
- ThreadPoolExecutor饱和策略和执行原理
    - AbortPolicy
    - CallerRunsPolicy
    - DiscardPolicy
    - DiscardOldestPolicy
- 线程池大小确定
    - 一般而言，cpu密集型为cpu+1，io密集型2*cpu+1；
    - 但是，实际工作中，是模拟线上环境，进行压力测试，使用visualVM观察线程的状态，并不断调整线程数得到的。
- BlockingQueue的选择 [线程池的三种队列区别](https://blog.csdn.net/qq_26881739/article/details/80983495?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1)
    - SynchronousQueue，无缓冲等待队列，通常要求maximumPoolSize无界（在某次添加元素后必须等待其他线程取走后才能继续添加）
    - LinkedBlockingQueue，无界缓存等待队列，相当于maxSize无效
    - ArrayBlockingQueue，有界缓存等待队列，生产上一般用这个，避免无界的元素和无界的线程导致OOM
12. Atomic原子类
- 介绍
    - 原子，一组操作要么都执行，要么都不执行
- juc包哪4类原子类
    - 基本类型
    - 数组
    - 引用
    - 引用字段
- AtomicInteger 原理
    - 通过CAS自旋实现（compare and swap）
- longaddr
    - 分段的思想，将整个值划分为多个槽，每次修改时根据hashCode选择一个槽位修改。计算总值时需要累加所有槽位的值
- 知道哪些并发容器
    - CopyOnWriteArrayList、ConcurrentLinkedQueue、BlockingQueue、ConcurrentLinkedQueue 等
- CopyOnWriteArrayList
    - 线程安全的容器，读取性能高
- CopyOnWriteArrayList怎么做到写读不互斥 读不加锁
    - CopyOnWrite写时复制，在副本进行修改，修改完毕后使原引用指向该副本；读取不加锁，写时加锁。
- ConcurrentLinkedQueue
    - 通过 CAS 操作实现
- 阻塞队列和非阻塞队列区别
    - 阻塞队列：阻塞队列通常用于生产者/消费者模型。当队列容器已满，生产者会被阻塞，直到队列未满；当队列容器为空时，消费者会被阻塞，直至队列非空
    - 非阻塞队列：没有前面说的这些特性
- BlockingQueue
    - ArrayBlockingQueue 用1个lock2个condition实现
    - LinkedBlockingQueue 用2个lock2个condition实现
    - PriorityBlockingQueue 优先队列，用1个lock一个condition实现
    - DelayQueue 延迟队列
- ConcurrentSkipListMap
    - JDK中使用跳表数据接口实现的Map，线程安全
- 跳表概念
    - 跳表是O(logn)的时间复杂度，用空间换时间，只需要局部调整便能维持树高度的平衡
    - 它的本质是同时维护了多个链表，并且链表是分层的，分为了原始链表，第一级索引，第二级索引..第n级索引
    - 然后手势描述一下，blablabla
13. AQS 
- 原理 理解
    - 如果哦共享资源未被锁定，那么便锁定资源，设置当前线程为工作线程；如果已被锁定，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列的变种来实现的
- clh队列 FIFO cas
    - clh 队列，没有显示的直接后继指针，而是通过在前驱节点上进行自旋来实现阻塞等待
    - 然后，AQS 对 clh 进行了增强，主要是增加了直接前驱和直接后继指针，并且是通过前驱节点释放锁时调用unparkSuccessor来唤醒后继节点的线程
- AQS对资源的共享方式
    - 独占式：如 ReentrenceLock
    - 共享式：如 CountDownLatch、CycleBarrier、Semphore
- AQS使用了什么设计模式
    - 模板方法模式
- 自定义AQS同步器需要重写哪些方法
    - isHeloExlusivlly
    - tryAcquire
    - tryRelease
    - tryAcquireShared
    - tryReleaseShared
- ReentrantLock  Semaphore CountDownLatch  CyclicBarrier 底层实现
    - ReentrantLock
        - 非公平锁：
            - CAS尝试获取，获取失败则再次CAS获取或重入；
            - 如果仍然失败，则将线程包装为等待节点并设置为tail节点，之后进入等待队列自旋
            - 自旋过程中会判断是否要进行park休眠，如果需要，线程便休眠；前驱节点唤醒时根据自旋逻辑会再次尝试获取锁
        - 公平锁：
            - 除了上述步骤外，在最开始会判断等待队列是否存在节点，如果不存在，才会去CAS尝试获取锁，否则，直接入队列
    - 其他 实现不清楚，应用的话我可以说一说，blablabla
14. gc
- Minor GC/Young GC 和 Major GC/Full GC 
    - Minor：新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快
    - Major：发生在老年代的 GC，Major GC 的速度一般会比 Minor GC 的慢 10 倍以上
- 如何判断对象是否死亡
    - 引用计数法：引用加1，失效减1，为0表示不能再使用。很难解决对象之间相互循环引用的问题
    - 可达性分析：当一个对象到 GC Roots 没有任何路径可达的话，则证明此对象是不可用的
- 强软弱虚引用
    - 强：任何时候都不回收，即使OOM
    - 软：内存不足时回收
    - 弱：发生GC时回收
    - 虚：随时可能回收
- 如何判断一个类是无用的类
    - 类的所有实例均已回收
    - 加载该类的ClassLoader已回收
    - 该类对应的Class对象没有在任何地方被引用，且无法在任何地方通过反射访问该类的方法
- gc有哪些算法，各自特点
    - 标记清除：分为“标记”阶段和“清除”阶段。效率不高，会产生大量内存碎片
    - 复制：将内存分为两块，当一块的内存使用完后，就将还存活的对象复制到另一块去
    - 标记整理：分为“标记”阶段和“整理”阶段。让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存
    - 分代收集：新生代选择复制算法，老年代选择“标记-清除”或“标记-整理”算法
- 标记清除，复制，标记整理，分代收集
    - 同上题
- 有哪些垃圾收集器
    - Serial 单线程串行。新生代采用复制算法，老年代采用标记-整理。简单而高效
    - ParNew 多线程并行。新生代采用复制算法，老年代采用标记-整理。简单而高效
    - Parallel Scavenge 多线程并行。新生代采用复制算法，老年代采用标记-整理。关注吞吐量，提供很多参数供调整。
    - Serial Old 单线程。Serial 收集器的老年代版本。简单而高效。
    - Paralel Old 多线程并行。Parallel Scavenge 收集器的老年代版本。关注吞吐量。
    - CMS 多线程并发。标记-清除。
    - G1 多线程并发。整体“标记整理”，局部“复制”算法。
- Serial ParNew Parallel Scavenge Serial Old  Parallel Old 
- CMS运行4个步骤 
    - 初始标记
    - 并发标记
    - 重新标记
    - 并发清除
- CMS 3个缺点
    - 对 CPU 资源敏感
    - 无法处理浮动垃圾
    - 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生
- G1 收集器4个特点
    - 并行与并发
    - 分代收集
    - 空间整合
    - 可预测的停顿
- G1 收集器4个步骤
    - 初始标记
    - 并发标记
    - 最终标记
    - 筛选回收
15. 类文件结构
- 文件结构和组件
    - 魔数
    - Class文件版本
    - 常量池
    - 访问标志
    - 当前类索引,父类索引与接口索引集合
    - 字段表集合
    - 方法表集合
    - 属性表集合
- 类加载过程
    - 分为 加载、连接、初始化、使用、卸载
- 加载阶段做了哪3件事
    - 根据全类名获取定义此类的二进制字节流
    - 将二进制字节流对应的数据存储结构转换为运行时数据区接口
    - 在内存中创建代表该类的 Class 对象，作为方法区这些数据的入访问口
- 连接阶段做了拿3件事
    - 验证
        - 文件格式验证
        - 元数据验证
        - 字节码验证
        - 符号引用验证
    - 准备
        - 分配内存并初始化零值
    - 解析
        - 符号引用替换为直接引用的过程
- 知道哪些类加载器
    - BootstrapClassLoader
    - ExtensionClassLoader
    - AppClassLoader
- 卸载的要求
    - 该类的所有对象都已经回收
    - 该类的ClassLoader已经回收
    - 该类对应的Class对象没有在任何地方被引用，且无法在任何地方通过反射访问该类的方法
- 介绍一下双亲委派模型
    - 在类加载的时候，首先判断是否被加载过。已经被加载的类会直接返回，否则才会尝试加载
    - 在加载的时候，首先会把该请求委派给父类加载器的 loadClass() 处理，因此所有的请求最终都委派给最顶层的启动类加载器
    - 当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器作为父类加载器。
- 双亲委派模型有什么好处
    - 可以避免类的重复加载
    - 另外也避免了java核心API被篡改
- 如何自定义类加载器
    - 继承 ClassLoader，重写 loadClass() 方法
## 面经：
- java线程模型和jvm线程模型
- 说一下java类加载器的工作机制？类加载在那个区域进行的？
- 说说java泛型，为什么称java泛型为伪泛型？泛型的好处有哪些？int可以作为泛型类型吗？
- 线程run和start的区别？两次start同一个线程会怎么样？
- 对concureent包了解吗？什么是cas？cas怎么解决ABA问题？讲一下CountDownLatch和cyclicBarrier的区别？并发包了解吗？假如几个线程之间相互等待，可以用哪个并发类来实现，他的原理是什么？2
- 没有做过GC调优，讲一下这么做的？
- GC的过程
- 强制young gc会有什么问题？
- 知道G1么？
- 回收过程是怎么样的？
- 你提到的Remember Set底层是怎么实现的？
- CMS4个阶段 CMS GC有什么问题？
- 怎么避免产生浮动垃圾？
- Jvm了解吗？jvm中哪些可以作为垃圾回收的gcroot?为什么呢？ 分析哪些是gc root对象
- 什么时候需要自定义类加载器？
- 什么时候静态方法加锁  什么时候实例方法加锁
- jvm安全点
- lock.interrupt底层原理
